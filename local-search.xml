<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>实习日志</title>
    <link href="/2024/07/05/%E5%AE%9E%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    <url>/2024/07/05/%E5%AE%9E%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="实习期间引发的一些想法"><a href="#实习期间引发的一些想法" class="headerlink" title="实习期间引发的一些想法"></a>实习期间引发的一些想法</h1><ol><li><p>使用Spring Cloud Gateway实现灰度发布功能</p></li><li><p>使用Spring Cloud Gateway实现负载均衡</p></li><li><p>使用Spring Cloud Gateway实现熔断功能</p></li><li><p>了解Kubernetes</p></li><li><p>通过</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">RequestRateLimiter</span><br>              <span class="hljs-attr">args:</span><br>                <span class="hljs-attr">redis-rate-limiter:</span><br>                  <span class="hljs-attr">replenishRate:</span> <span class="hljs-number">10</span><br>                  <span class="hljs-attr">burstCapacity:</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>实现限流功能</p></li></ol><h1 id="2024-6-25"><a href="#2024-6-25" class="headerlink" title="2024-6-25"></a>2024-6-25</h1><h2 id="巩固MyBatis-Plus知识"><a href="#巩固MyBatis-Plus知识" class="headerlink" title="巩固MyBatis-Plus知识"></a>巩固MyBatis-Plus知识</h2><p>重新整理一下Spring-Boot整合Mybatis-Plus流程</p><p><strong>一、导入Mybatis-Plus依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>二、开启Mybatis-Plus SQL查询语句日志</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br></code></pre></td></tr></table></figure><p>但是开启查询语句日志，也可以直接在nacos上配置mybatis为debug</p><p><strong>三、使用Mybatis-X插件生成实体类、Service层和Mapper层</strong></p><p>安装 Mybatis-X 插件，连接数据源，选择需要生成的数据库表右键选择 MybatisX-generator，按以下配置</p><p><img src="/.com//image-20240705101921276.png" alt="image-20240705101921276"></p><p><img src="/.com//image-20240705101927052.png" alt="image-20240705101927052"></p><p><strong>四、修改生成出来的Mapper文件里面所对应的实体类的位置</strong></p><p><strong>五、给 Spring-Boot 主类添加 Mapper扫描</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapperScan(&quot;com.wenjelly.wenjellyojbackendquestionservice.mapper&quot;)</span> # 对应的mapper包地址<br></code></pre></td></tr></table></figure><p><strong>六、Service接口要继承 IService&lt;实体类名&gt;</strong></p><p><strong>七、Service实现类要继承ServiceImpl&lt;对应的Mapper类, 实体类名&gt;</strong></p><p><strong>八、Mapper接口则要继承BaseMapper&lt;实体类名&gt;</strong></p><p>然后即可在controller实现大部分增删查改。</p><h1 id="2024-6-27"><a href="#2024-6-27" class="headerlink" title="2024-6-27"></a>2024-6-27</h1><h2 id="删除儿保订单的接口改为通过体检单id"><a href="#删除儿保订单的接口改为通过体检单id" class="headerlink" title="删除儿保订单的接口改为通过体检单id"></a>删除儿保订单的接口改为通过体检单id</h2><blockquote><p>时间：2024-6-27：11:40 ~ 2024-6-27：11:57</p><p>需求：将原本的根据id删除儿保订单修改为根据体检单id删除</p><p>代码修改位置：<code>gongwei-module-physical-biz/src/main/java/</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;com.gongwei.cloud.<span class="hljs-keyword">module</span>.physical.controller.admin.childsearchorders.ChildsearchordersController<br>&gt;com.gongwei.cloud.<span class="hljs-keyword">module</span>.physical.service.childsearchorders.ChildsearchordersServiceImp<br></code></pre></td></tr></table></figure><p>涉及的数据库表：physical_child_search_orders</p><p>接口名称：&#x2F;physical&#x2F;child-search-orders&#x2F;delete</p></blockquote><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>增删查改</p><p>Controller层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DeleteMapping(&quot;/delete&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;删除儿保项目筛查订单&quot;)</span><br><span class="hljs-meta">@ApiImplicitParam(name = &quot;id&quot;, value = &quot;编号&quot;, required = true, dataTypeClass = String.class)</span><br><span class="hljs-meta">@PreAuthorize(&quot;@ss.hasPermission(&#x27;physical:child-search-orders:delete&#x27;)&quot;)</span><br><span class="hljs-keyword">public</span> CommonResult&lt;Boolean&gt; <span class="hljs-title function_">deleteChildSearchOrders</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;id&quot;)</span> String physicalId)</span> &#123;<br>    childSearchOrdersService.deleteChildSearchOrders(physicalId);<br>    <span class="hljs-keyword">return</span> success(<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Service层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteChildSearchOrders</span><span class="hljs-params">(String physicalId)</span> &#123;<br>    <span class="hljs-comment">// 校验存在</span><br>    <span class="hljs-built_in">this</span>.validateChildSearchOrdersExistsByPhysicalId(physicalId);<br>    <span class="hljs-comment">// 删除</span><br>    childSearchOrdersMapper.delete(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapperX</span>&lt;ChildSearchOrdersDO&gt;()<br>            .eq(ChildSearchOrdersDO::getPhysicalId, physicalId));<br>&#125;<br><span class="hljs-comment">// 校验存在方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">validateChildSearchOrdersExistsByPhysicalId</span><span class="hljs-params">(String physicalId)</span> &#123;<br>    <span class="hljs-type">ChildSearchOrdersDO</span> <span class="hljs-variable">childSearchOrdersDO</span> <span class="hljs-operator">=</span> childSearchOrdersMapper<br>        .selectOne(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapperX</span>&lt;ChildSearchOrdersDO&gt;()<br>            .eq(ChildSearchOrdersDO::getPhysicalId, physicalId));<br>    <span class="hljs-keyword">if</span> (ObjectUtils.isEmpty(childSearchOrdersDO)) &#123;<br>        <span class="hljs-keyword">throw</span> exception(CHILD_SEARCH_ORDERS_NOT_EXISTS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="根据居民id得到筛查时间-TODO-有点慢，可能得优化（已优化一次）"><a href="#根据居民id得到筛查时间-TODO-有点慢，可能得优化（已优化一次）" class="headerlink" title="根据居民id得到筛查时间 TODO 有点慢，可能得优化（已优化一次）"></a>根据居民id得到筛查时间 TODO 有点慢，可能得优化（已优化一次）</h2><blockquote><p>时间：2024-6-27 :10:07 ~ 2024-6-27:17:10</p><p>需求：传入一个居民id，根据id返回最新的筛查时间与筛查类型，筛查类型有骨密度筛查、听力筛查······</p><p>代码修改位置：<code>gongwei-module-physical-biz/src/main/java/</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;com.gongwei.cloud.<span class="hljs-keyword">module</span>.physical.controller.admin.childsearchorders.ChildSearchOrdersController;<br>&gt;com.gongwei.cloud.<span class="hljs-keyword">module</span>.physical.service.childsearchorders.ChildSearchOrdersServiceImp;<br>&gt;com.gongwei.cloud.<span class="hljs-keyword">module</span>.physical.service.childsearchorders.ChildSearchOrdersService;<br></code></pre></td></tr></table></figure><p>涉及的数据库表：physical_data_info（体检单信息）、physical_data_project（查日期）、physical_data_package（查体检套餐名称）、physical_medical_packages（查体检类型）</p><p>接口名称：&#x2F;physical&#x2F;child-search-orders&#x2F;getSearchDateByResidentId</p></blockquote><h3 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>Controller层：新增方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据居民id查询体检类型及最新体检日期</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> residentId 居民id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 体检套餐-最新体检日期的键值对</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(&quot;/getSearchDateByResidentId&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;根据居民id得到筛查时间&quot;)</span><br><span class="hljs-keyword">public</span> CommonResult&lt;HashMap&lt;String, String&gt;&gt; <span class="hljs-title function_">getSearchDateByResidentId</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;residentId&quot;)</span> String residentId)</span> &#123;<br>    <span class="hljs-keyword">return</span> success(childSearchOrdersService.getSearchDateByResidentId(residentId));<br>&#125;<br></code></pre></td></tr></table></figure><p>Service接口：新增方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据居民id查询体检类型及最新体检日期</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> residentId 居民id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 体检套餐-最新体检日期的键值对</span><br><span class="hljs-comment"> */</span><br>HashMap&lt;String, String&gt; <span class="hljs-title function_">getSearchDateByResidentId</span><span class="hljs-params">(String residentId)</span>;<br></code></pre></td></tr></table></figure><p>Service实现：</p><ol><li>先查出这个居民对应的所有体检单id集合</li><li>通过遍历体检单id集合，一条一条的查询单条体检单的体检类型和体检日期</li><li>先判断日期是否为空，为空则跳过去遍历下一条体检单。</li><li>如果日期不为空，则判断hashmap里面是否已经存在在了对应的套餐类型-日期</li><li>如果存在了就判断哪个日期比较新，把新的更改进去</li><li>如果不存在则直接添加进去</li><li><strong>优化：一开始是将日期、体检套餐名称、体检类型一次性全查出来了，优化后是先查日期，如果日期不存在就不需要查另外俩张表了</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> HashMap&lt;String, String&gt; <span class="hljs-title function_">getSearchDateByResidentId</span><span class="hljs-params">(String residentId)</span> &#123;<br><br>    <span class="hljs-comment">// 返回结果 key是套餐类型，value是体检日期</span><br>    HashMap&lt;String, String&gt; typeDateMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">// 用于比较日期大小,判断是否是最新的日期</span><br>    <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br><br>    <span class="hljs-comment">// 得到体检单id集合</span><br>    List&lt;String&gt; physicalIds = dataInfoMapper.selectList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapperX</span>&lt;DataInfoDO&gt;()<br>                    .eq(DataInfoDO::getResidentId, residentId))<br>            .stream().map(DataInfoDO::getId)<br>            .collect(Collectors.toList());<br>    physicalIds.forEach(<br>            physicalId -&gt; &#123;<br>                <span class="hljs-type">DataProjectDO</span> <span class="hljs-variable">dataProjectDO</span> <span class="hljs-operator">=</span> dataProjectMapper.selectOne(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapperX</span>&lt;DataProjectDO&gt;()<br>                        .eq(DataProjectDO::getPhysicalId, physicalId)<br>                        .apply(<span class="hljs-string">&quot;field_config -&gt;&#x27;$.fieldCode&#x27; = &#x27;F16759409655184250&#x27;&quot;</span>));<br>                <span class="hljs-comment">// 判断日期是否为空，如果为空，就不用查询套餐类型了,不为空才查询套餐类型</span><br>                <span class="hljs-keyword">if</span> (ObjectUtils.isNotEmpty(dataProjectDO) &amp;&amp; ObjectUtils.isNotEmpty(dataProjectDO.getProjectValue())) &#123;<br>                    <span class="hljs-comment">// 查询这条体检单的套餐名称</span><br>                    <span class="hljs-type">String</span> <span class="hljs-variable">packageId</span> <span class="hljs-operator">=</span> dataPackageMapper.selectOne(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapperX</span>&lt;DataPackageDO&gt;()<br>                            .eq(DataPackageDO::getPhysicalId, physicalId)).getPackageId();<br>                    <span class="hljs-comment">// 通过packageId 查询套餐类型</span><br>                    <span class="hljs-type">String</span> <span class="hljs-variable">packageType</span> <span class="hljs-operator">=</span> medicalPackagesMapper.selectOne(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapperX</span>&lt;MedicalPackagesDO&gt;()<br>                            .eq(MedicalPackagesDO::getId, packageId)).getType();<br>                    <span class="hljs-comment">// 判断Map是否已有该类型的日期了</span><br>                    <span class="hljs-keyword">if</span> (ObjectUtils.isNotEmpty(typeDateMap.get(packageType))) &#123;<br>                        <span class="hljs-comment">// 如果有，则比较日期大小</span><br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-keyword">if</span> (ft.parse(dataProjectDO.getProjectValue()).after(ft.parse(typeDateMap.get(packageType)))) &#123;<br>                                typeDateMap.put(packageType, dataProjectDO.getProjectValue());<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 没有则直接添加</span><br>                        typeDateMap.put(packageType, dataProjectDO.getProjectValue());<br>                    &#125;<br>                &#125;<br>            &#125;<br>    );<br>    <span class="hljs-keyword">return</span> typeDateMap;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2024-6-28"><a href="#2024-6-28" class="headerlink" title="2024-6-28"></a>2024-6-28</h1><h2 id="将体检单详情加入Redis缓存中，并优先从这里面进行读取-会报错，原因未知"><a href="#将体检单详情加入Redis缓存中，并优先从这里面进行读取-会报错，原因未知" class="headerlink" title="将体检单详情加入Redis缓存中，并优先从这里面进行读取(会报错，原因未知)"></a>将体检单详情加入Redis缓存中，并优先从这里面进行读取(会报错，原因未知)</h2><p>想法：目前我是将方法内的最后的结果加入到redis中，也就是一个list集合，如果我将每次查询的单个结果都加入到redis中，然后再最后将redis一个个结果添加到列表中是否会好一些？</p><blockquote><p>时间：2024-6-28 :14:17 ~ 2024-6-28:16:37</p><p>需求：获取体检项目的体检单详情时，先从Redis缓存中读取，如果没有再从数据库中读取，读取后再将内容加入Redis缓存中</p><p>代码修改位置：<code>gongwei-module-physical-biz/src/main/java/</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;com.gongwei.cloud.<span class="hljs-keyword">module</span>.physical.service.dataproject.DataProjectServiceImp;<br></code></pre></td></tr></table></figure><p>涉及的数据库表：无</p><p>接口名称：&#x2F;physical&#x2F;data-project&#x2F;getProjectById</p></blockquote><h3 id="实现步骤-2"><a href="#实现步骤-2" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>Service实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 对id和projectId进行加密</span><br><span class="hljs-type">String</span> <span class="hljs-variable">idKey</span> <span class="hljs-operator">=</span> Base64Encoder.encode(id);<br><span class="hljs-type">String</span> <span class="hljs-variable">projectIdKey</span> <span class="hljs-operator">=</span> Base64Encoder.encode(projectId);<br><span class="hljs-type">String</span> <span class="hljs-variable">redisKey</span> <span class="hljs-operator">=</span> idKey + projectIdKey;<br><span class="hljs-comment">// 先查询redis是否有缓存</span><br><span class="hljs-keyword">if</span> (redisUtil.isKeyExist(redisKey)) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">jsonString</span> <span class="hljs-operator">=</span> redisUtil.getCacheObject(redisKey);<br>    List&lt;DataProjectFormRespVO&gt; dataProjectFormRespVOList = JSONObject.parseArray(jsonString, DataProjectFormRespVO.class);<br>    <span class="hljs-keyword">return</span> dataProjectFormRespVOList;<br>&#125;<br><span class="hljs-comment">// 如果没有，就加入到redis缓存</span><br><span class="hljs-comment">// 加入到redis缓存中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">jsonString</span> <span class="hljs-operator">=</span> JsonUtils.toJsonString(dataProjectFormRespVOList);<br>redisUtil.setCacheObject(redisKey,jsonString,<span class="hljs-number">24</span>,TimeUnit.HOURS);<br></code></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如果医生修改了数据，点击保存，还需要更新redis里面的内容，该如何更改</p><p>答：见2024-7-2日实习日志</p><h1 id="2024-7-2"><a href="#2024-7-2" class="headerlink" title="2024-7-2"></a>2024-7-2</h1><h2 id="医生修改体检项目信息时，需要更新redis缓存内容-todo"><a href="#医生修改体检项目信息时，需要更新redis缓存内容-todo" class="headerlink" title="医生修改体检项目信息时，需要更新redis缓存内容 &#x2F;todo"></a>医生修改体检项目信息时，需要更新redis缓存内容 &#x2F;todo</h2><blockquote><p>时间：2024-7-2 :9:00 ~ 2024-7-2:16:30</p><p>需求：当医生更新了用户体检项目的内容时，需要将redis里的内容进行更新</p><p>代码修改位置：<code>gongwei-module-physical-biz/src/main/java/</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;com.gongwei.cloud.<span class="hljs-keyword">module</span>.physical.service.dataproject.DataProjectServiceImp;<br></code></pre></td></tr></table></figure><p>涉及的数据库表：无</p><p>接口名称：&#x2F;physical&#x2F;data-project&#x2F;update</p></blockquote><h3 id="实现步骤-3"><a href="#实现步骤-3" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>Service实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 异步更新redis缓存</span><br>CompletableFuture.runAsync(() -&gt; &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">physicalId</span> <span class="hljs-operator">=</span> updateReqVO.getPhysicalId();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">projectId</span> <span class="hljs-operator">=</span> updateReqVO.getProjectId();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">redisKey</span> <span class="hljs-operator">=</span> Base64Encoder.encode(physicalId + projectId);<br>    <span class="hljs-keyword">if</span> (redisUtil.isKeyExist(redisKey)) &#123;<br>        <span class="hljs-comment">// 删除 redis</span><br>        redisUtil.deleteObject(redisKey);<br>        <span class="hljs-comment">// 更新 redis 缓存</span><br>        getProjectById(physicalId, projectId);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>我的想法：一开始我是根据修改内容进行重新绑定，但是有些属性会消失，所以想了一个偷懒方法：修改完成后，直接删除对应的redis缓存，然后再通过上面的查询方法再次生成一个redis缓存，并且采用异步方式</strong></p><p>但是我觉得不够完美，或许先把查询接口的业务逻辑全部理清之后再优化一次会更好，这样或许就不用通过重新查询来生成redis了</p><h2 id="学习LambdaQueryWrapper-likeIfPresent的用法"><a href="#学习LambdaQueryWrapper-likeIfPresent的用法" class="headerlink" title="学习LambdaQueryWrapper.likeIfPresent的用法"></a>学习LambdaQueryWrapper.likeIfPresent的用法</h2><p><code>LambdaQueryWrapper.likeIfPresent</code> 是 <a href="https://geek.csdn.net/edu/47a0da7218b411332ba4349ff5e2a4c2?dp_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6NDQ0MDg2MiwiZXhwIjoxNzA3MzcxOTM4LCJpYXQiOjE3MDY3NjcxMzgsInVzZXJuYW1lIjoid2VpeGluXzY4NjQ1NjQ1In0.RrTYEnMNYPC7AQdoij4SBb0kKEgHoyvF-bZOG2eGQvc&spm=1055.2569.3001.10083">mybatis</a>-Plus 框架中的一个查询条件构造器方法。该方法用于在查询条件中添加一个模糊查询条件，如果传入的值不为空则生效，否则忽略该条件</p><p>用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;MedicalPackagesDO&gt; medicalPackagesDOS = medicalPackagesMapper.selectList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapperX</span>&lt;MedicalPackagesDO&gt;()<br>                .eqIfPresent(MedicalPackagesDO::getType, type)<br>             .likeIfPresent(MedicalPackagesDO::getName, name));<br></code></pre></td></tr></table></figure><h1 id="2024-7-3"><a href="#2024-7-3" class="headerlink" title="2024-7-3"></a>2024-7-3</h1><h2 id="修改BUG-显示筛查最新日期"><a href="#修改BUG-显示筛查最新日期" class="headerlink" title="修改BUG 显示筛查最新日期"></a>修改BUG 显示筛查最新日期</h2><p>无需记录，在返回结果列表时，将里面的日期查询倒过来</p><h2 id="功能优化-根据sort类型排序套餐"><a href="#功能优化-根据sort类型排序套餐" class="headerlink" title="功能优化 根据sort类型排序套餐"></a>功能优化 根据sort类型排序套餐</h2><p>无需记录，在套餐列表使用流式stream().sorted(Comparator.comparingInt(MedicalPackagesRespVO::getSort)).collect(toList())返回即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">.stream().sorted(Comparator.comparingInt(MedicalPackagesDO::getSort)).collect(toList());<br></code></pre></td></tr></table></figure><p>关于stream.sorted的用法：</p><p>当参数为空时，默认排序</p><p>想要自定义排序如下：</p><ol><li><p>根据流中对象的某个属性进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sorted(Comparator.comparingInt(Object::getXXX)) <span class="hljs-comment">// Int可修改为Long、Doublue</span><br></code></pre></td></tr></table></figure></li><li><p>倒叙排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">list.stream().sorted(Comparator.reverseOrder());<br><span class="hljs-comment">// 或者</span><br>list.stream().sorted(Comparator.comparing(Student::getAge).reversed())<br></code></pre></td></tr></table></figure></li><li><p>含空值排序：有时候数据库会有一些错误数据，但是又要求程序不能报错，这怎么办呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 含空值的正序(升序)排序(按创建时间排序) </span><br><span class="hljs-comment">// nullsFirst：空值放第一位</span><br>list.stream().sorted(Comparator.comparing(l -&gt; l.getCreateTime(), Comparator.nullsFirst(Date::compareTo).reversed())).collect(Collectors.toList());<br><br><span class="hljs-comment">// 含空值的倒序(降序)排序</span><br><span class="hljs-comment">// nullsFirst：空值放第一位</span><br>list=list.stream()<br>.sorted(Comparator.comparing(l -&gt; l.getCreateTime(), Comparator.nullsFirst(Date::compareTo).reversed()))<br>.collect(Collectors.toList());<br></code></pre></td></tr></table></figure><ol start="4"><li><p>自定义排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">sorted(Comparator com) <span class="hljs-comment">// Comparator排序器自定义排序</span><br><span class="hljs-comment">// 先按工资再按年龄自定义排序（降序）</span><br>List&lt;String&gt; newList4 = personList.stream().sorted((p1, p2) -&gt; &#123;<br>  <span class="hljs-keyword">if</span> (p1.getSalary() == p2.getSalary()) &#123;<br>    <span class="hljs-keyword">return</span> p2.getAge() - p1.getAge();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> p2.getSalary() - p1.getSalary();<br>  &#125;<br>&#125;).map(Person::getName).collect(Collectors.toList());<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="阿里云OSS对象存储返回路径优化"><a href="#阿里云OSS对象存储返回路径优化" class="headerlink" title="阿里云OSS对象存储返回路径优化"></a>阿里云OSS对象存储返回路径优化</h2><p>使用stream.filter去掉与源路径相同的路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">OSS</span> <span class="hljs-variable">ossClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OSSClientBuilder</span>().build(endpoint, accessId, accessKey);<br>        <span class="hljs-type">ObjectListing</span> <span class="hljs-variable">objectListing</span> <span class="hljs-operator">=</span> ossClient.listObjects(bucketName, filePath);<br>        List&lt;String&gt; keyList = objectListing.getObjectSummaries().stream()<br>                .filter(t -&gt; !((filePath + <span class="hljs-string">&quot;/&quot;</span>).equals(t.getKey())))<br>                .map(OSSObjectSummary::getKey).collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h1 id="2024-7-4"><a href="#2024-7-4" class="headerlink" title="2024-7-4"></a>2024-7-4</h1><h2 id="基于湛江中小学报告创建肇庆中小学报告"><a href="#基于湛江中小学报告创建肇庆中小学报告" class="headerlink" title="基于湛江中小学报告创建肇庆中小学报告"></a>基于湛江中小学报告创建肇庆中小学报告</h2><blockquote><p>时间：2024-7-4 :14:00 ~ 2024-7-4:19:00</p><p>需求：基于湛江中小学报告新增肇庆中小学报告，新增一些属性、删除一些属性</p><p>代码修改位置：<code>gongwei-module-physical-biz/src/main/java/</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;com.gongwei.cloud.<span class="hljs-keyword">module</span>.physical.controller.admin.inspectionrecordsheet;<br></code></pre></td></tr></table></figure><p>涉及的数据库表：无</p><p>接口名称：&#x2F;getZhaoQingMiddlePrimarySchoolReportSheet</p></blockquote><p>应该是用了某种设计模式，基于湛江的报告代码进行修改即可</p><h3 id="实现步骤-4"><a href="#实现步骤-4" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>Controller层：创建新接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@GetMapping(&quot;/getZhaoQingMiddlePrimarySchoolReportSheet&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;获取肇庆中小学健康检查表&quot;)</span><br><span class="hljs-meta">@ApiImplicitParam(name = &quot;id&quot;, value = &quot;体检单id&quot;, required = true, dataTypeClass = String.class)</span><br><span class="hljs-keyword">public</span> CommonResult&lt;ChildrenRecordVO&gt; <span class="hljs-title function_">getZhaoQingMiddlePrimarySchoolReportSheet</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;id&quot;)</span> String id)</span> &#123;<br>    <span class="hljs-keyword">return</span> success(inspectionRecordSheetService.getZhaoQingMiddlePrimarySchoolReportSheet(id));<br>&#125;<br></code></pre></td></tr></table></figure><p>Service层：创建新接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取肇庆中小学健康检查表</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br>ChildrenRecordVO <span class="hljs-title function_">getZhaoQingMiddlePrimarySchoolReportSheet</span><span class="hljs-params">(String id)</span>;<br></code></pre></td></tr></table></figure><p>Service实现类：实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ChildrenRecordVO <span class="hljs-title function_">getZhaoQingMiddlePrimarySchoolReportSheet</span><span class="hljs-params">(String id)</span> &#123;<br>    <span class="hljs-type">InspectionRecordHandler</span> <span class="hljs-variable">inspectionRecordHandler</span> <span class="hljs-operator">=</span> HandlerSheetFactory.getInspectionRecordHandler(ZHAO_QING_MIDDLE_PRIMARY_SCHOOL_REPORT.getType());<br>    <span class="hljs-type">ChildrenRecordVO</span> <span class="hljs-variable">inspectionRecord</span> <span class="hljs-operator">=</span> inspectionRecordHandler.getInspectionRecordById(id);<br>    inspectionRecord.setHospitalName(getHospitalName());<br>    <span class="hljs-keyword">return</span> inspectionRecord;<br>&#125;<br></code></pre></td></tr></table></figure><p>新建肇庆报告返回VO，里面有报告所需要的数据内容：体检名字、体检信息、体检用户信息等</p><h2 id="肇庆中小学报告的批量发布"><a href="#肇庆中小学报告的批量发布" class="headerlink" title="肇庆中小学报告的批量发布"></a>肇庆中小学报告的批量发布</h2><p>感觉运用了某种设计模式，新建一个类即可</p><p>基于湛江批量发布报告模板新建一个肇庆批量发布报告模板，同时将里面的湛江内容全部替换成肇庆即可</p><h2 id="一些有用的知识"><a href="#一些有用的知识" class="headerlink" title="一些有用的知识"></a>一些有用的知识</h2><p><strong>优雅处理空对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional.ofNullable(dataInfo).orElseThrow(() -&gt; exception(INSPECTION_RECORD_SHEET_DATA_INFO_EMPTY));<br></code></pre></td></tr></table></figure><p>将<code>dataInfo</code>对象使用<code>ofNullable</code>封装成<code>Optional</code>类，由于<code>ofNullable</code>能够接收一个为空的对象，当其为空时，<code>Optional</code>则为空，这样就不会当<code>dataInfo</code>对象为空时抛出<code>NullPointerException</code>了，当<code>dataInfo</code>有值时，就直接封装成<code>Optional</code>类。</p><p><code>orElseThrow（）</code>是对前面的<code>Optional</code>对象进行操作，如果<code>Optional</code>对象不为空，则会直接返回这个值，否则会执行传递给<code>orElseThrow</code>的lambda表达式。</p><p>如上代码就是通过<code>lambda</code>表达式调用了<code>exception</code>的方法生成并抛出一个异常</p><p>综上所述，整个代码段的作用是尝试获取<code>dataInfo</code>对象，如果<code>dataInfo</code>不为<code>null</code>，则直接使用；如果为<code>null</code>，则通过调用<code>exception</code>方法生成异常并抛出，以此来避免程序因为<code>null</code>值而产生不期望的行为，增强了代码的健壮性和可读性。</p><p><strong>条形码的生成、转化为字符串用于前端展示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 条形码的生成</span><br><span class="hljs-type">BufferedImage</span> <span class="hljs-variable">generate</span> <span class="hljs-operator">=</span> QrCodeUtil.generate(dataInfo.getBarCode(), BarcodeFormat.CODE_128, <span class="hljs-number">94</span>, <span class="hljs-number">40</span>);<br><span class="hljs-comment">// 条形码图像转换为Base64字符串:</span><br><span class="hljs-type">String</span> <span class="hljs-variable">barCodeImage</span> <span class="hljs-operator">=</span> ImageUtils.BufferedImageToBase64(generate);<br><span class="hljs-comment">// 设置条形码</span><br>zhaoQingMiddlePrimarySchoolSheetVO.setBarCodeImage(barCodeImage);<br></code></pre></td></tr></table></figure><p><code>String content</code>：生成的二维码 &#x2F; 条形码里面包含的信息，可以是用户的id等</p><p><code>BarcodeFormat format：BarcodeFormat.CODE_128</code>：指定生成的条形码格式为CODE 128，这是一种高密度且具有高数据容量的线性条形码符号体系，广泛应用于工业、零售和物流等领域。</p><p><code>int width、height</code>：码的宽高，设置为94、40时是条形码，单位通常是像素</p><p>以上方法执行后，会返回一个表示生成条形码的<code>BufferedImage</code>对象。</p><p>将条形码图像转换为Base64字符串：<code>ImageUtils.BufferedImageToBase64(generate)</code>;</p><p>通过这个方法会将图像数据转换为Base64编码的字符串，这样就可以方便地将图像嵌入到HTML、JSON等文本格式中进行传输或存储，而无需单独处理图像文件。</p><p><strong>流中的.distinct（） 用于对集合去重</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; configIds = dataProjectList.stream()<br>    .map(DataProjectDO::getConfigId).distinct().collect(Collectors.toList());<br></code></pre></td></tr></table></figure><p><strong>BUG</strong></p><p>错误: 找不到或无法加载主类 @C:\Users\14456\AppData\Local\Temp\idea_arg_file1844178482</p><p>解决</p><p><img src="/.com//image-20240704153708296-1720078628602-1.png" alt="image-20240704153708296"></p><p>选择这个</p><p><img src="/.com//image-20240704153724875.png" alt="image-20240704153724875"></p><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>在7-4实习的这一天，部门的开发环境崩掉了，其中有一个问题就是数据库服务起不来了，查找到原因发现是数据库磁盘满了，于是引发我的思考，数据库磁盘满了怎么办？</p>]]></content>
    
    
    
    <tags>
      
      <tag>标签</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将一个单体项目改造为微服务项目流程</title>
    <link href="/2024/07/04/%E5%B0%86%E4%B8%80%E4%B8%AA%E5%8D%95%E4%BD%93%E9%A1%B9%E7%9B%AE%E6%94%B9%E9%80%A0%E4%B8%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/07/04/%E5%B0%86%E4%B8%80%E4%B8%AA%E5%8D%95%E4%BD%93%E9%A1%B9%E7%9B%AE%E6%94%B9%E9%80%A0%E4%B8%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="关于微服务改造中的请求转发模块"><a href="#关于微服务改造中的请求转发模块" class="headerlink" title="关于微服务改造中的请求转发模块"></a>关于微服务改造中的请求转发模块</h2><p><strong>注意：以下所有依赖都对应Spring Boot 2.6.13版本、Spring Cloud Alibaba 2021.0.5.0版本</strong></p><p>记录一下将OJ系统改造成微服务中，网关服务的编写</p><p>启动Nacos，单独模式</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">startup.<span class="hljs-built_in">cmd</span> -m standalone<br></code></pre></td></tr></table></figure><p>首先，抽取各个模块之间想要通信调用别的模块的内容</p><p>比如：</p><p>题目模块需要使用用户模块的一下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">getById(<span class="hljs-type">long</span> userId);<br>listByIds(List&lt;<span class="hljs-type">long</span>&gt; idList);<br>getUserVO(User user);<br>·····<br></code></pre></td></tr></table></figure><p>那么，可以在service-client模块中，编写一个<code>userFeignClient</code>接口，用于转发&#x2F;提供 用户模块暴露给外面的接口调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">userFeignClient</span> &#123;<br>    <span class="hljs-comment">// 暴露在外面的接口</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为了使<code>userFeignClient</code>能够被注册中心发现，使用<code>@FeignClient</code>注解</p><p>变量为有</p><p><code>name</code>：在服务中心注册的名称，一般转发给哪个模块就用哪个模块的服务名称命名</p><p><code>path</code>：接收网关的路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name = &quot;$&#123;该接口在注册中心的名字&#125;&quot;,path = &quot;$&#123;通过哪个路径转发到该接口&#125;&quot;)</span><br></code></pre></td></tr></table></figure><p>添加完之后就是这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name=&quot;wenjellyoj-backend-user-service&quot;,path=&quot;/api/user/inner&quot;)</span><br><span class="hljs-comment">// 使用/inner是标识这是内网转发</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">userFeignClient</span>&#123;<br>    <span class="hljs-comment">// 暴露给其他模块的接口</span><br>    User <span class="hljs-title function_">getById</span><span class="hljs-params">(<span class="hljs-type">long</span> userId)</span>;<br>    List&lt;User&gt; <span class="hljs-title function_">listByIds</span><span class="hljs-params">(List&lt;<span class="hljs-type">long</span>&gt; idList)</span>;<br>UserVO <span class="hljs-title function_">getUserVO</span><span class="hljs-params">(User user)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，做到这里还并没有完成，这里只是将网关的请求发送过来了而已，而如果根据请求去执行处理逻辑就行接下来要讨论的内容</p><ol><li><p>当有请求进来时，可以直接在这个接口里面默认实现，比如直接在该接口默认实现。什么情况需要这样呢？比如要处理一个request请求的时候，由于request请求在一次次转发过程中需要被多次序列化，而可能会导致数据丢失（我也不知道能不能这样解释，后续再修改吧&#x2F;&#x2F; TODO）、或者执行逻辑非常简单时（不必浪费资源进行转发），就可以选择直接在接口默认实现具体操作如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(name=&quot;wenjellyoj-backend-user-service&quot;,path=&quot;/api/user/inner&quot;)</span><br><span class="hljs-comment">// 使用/inner是标识这是内网转发</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">userFeignClient</span>&#123;<br>    <span class="hljs-comment">// 接口内默认实现</span><br>    <span class="hljs-comment">// 获取登录登录</span><br>    <span class="hljs-keyword">default</span> User <span class="hljs-title function_">getLoginUser</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">userObj</span> <span class="hljs-operator">=</span> request.getSession().getAttribute(USER_LOGIN_STATE);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">currentUser</span> <span class="hljs-operator">=</span> (User) userObj;<br>        <span class="hljs-keyword">if</span> (currentUser == <span class="hljs-literal">null</span> || currentUser.getId() == <span class="hljs-literal">null</span>) &#123;<br>thorw <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessExeption</span>(ErrorCode.NOT_LOGIN_ERROR);<br>        &#125;<br>        <span class="hljs-keyword">return</span> currentUser;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>第二种就是将进来的请求再次转发给对应的模块，然后让模块进行处理，毕竟这就是这个转发模块的主要工作，当不使用第一种时，就可以使用这一种方式，具体操作如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在对应的方法上面加上 @GetMapping(&quot;路径&quot;)注解，同时在方法的参数里面加上 @RequestParam(&quot;参数名称&quot;)</span><br><span class="hljs-meta">@GetMapping(&quot;/get/id&quot;)</span><br>User <span class="hljs-title function_">getById</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;userId&quot;)</span> <span class="hljs-type">long</span> userId)</span>;<br></code></pre></td></tr></table></figure><p>这样，当有请求进来时，就可以解析路径与参数，再转发给对应的模块的具体处理了</p></li></ol><p><strong>编写完了转发请求之后，接下来就是编写这些内部请求的处理逻辑了</strong></p><p>在用户模块下的<code>Controller</code>包下新建一个<code>inner</code>包，里面存放处理上述（简称中转站）转发过来的请求</p><p>新建<code>InnerUserController</code>类并实现<code>UserFeignClient</code>接口，发现在用户请求中转站中，有俩条请求需要进行处理，一个是<code>getById</code>，一个是<code>listByIds</code></p><p>以下是<code>InnerUserController</code>处理这俩个请求的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/inner&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerUserController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserFeignClient</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据用户id获取用户</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userId 用户id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 用户对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@GetMapping(&quot;/get/id&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getById</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;userId&quot;)</span> <span class="hljs-type">long</span> userId)</span> &#123;<br>        <span class="hljs-keyword">return</span> userService.getById(userId);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据id列表返回用户列表</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> idList id列表</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 用户集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/get/ids&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">listByIds</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;idList&quot;)</span> Collection&lt;Long&gt; idList)</span> &#123;<br>        <span class="hljs-keyword">return</span> userService.listByIds(idList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>编写完转发处理之后便是开始Nacos</strong></p><p>配置流程如下：</p><ol><li><p>给全部引入nacos依赖，先在父项目中引入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>给需要注册的服务添加如下配置，用于指定Nacos位置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br><span class="hljs-attr">cloud:</span><br><span class="hljs-attr">nacos:</span><br><span class="hljs-attr">discovery:</span><br><span class="hljs-attr">service-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span><br></code></pre></td></tr></table></figure></li><li><p>开启nacos服务端，客户端需要去官网下载，开启后访问地址 localhost:8848&#x2F;nacos</p></li><li><p>给项目启动类打上注解，开启注册发现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-meta">@EnableFeignClients(basePackages = &#123;&quot;com.wenjelly.wenjellyojbackendserviceclient.service&quot;&#125;)</span><br></code></pre></td></tr></table></figure><p>当我们启动服务之后，识别到@EnableDiscoveryClient注解后，服务就会去Nacos上进行服务注册，当这个服务需要调用别的模块的服务的时候，识别到@EnableFeignClients注解后，会优先去指定的包下寻找能够解析请求的 方法</p></li></ol><p><strong>启动中遇到的一些问题：</strong></p><p>在各个模块中Spring Boot启动类上还需要添加一些注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@MapperScan(&quot;com.wenjelly.wenjellyojbackendquestionservice.mapper&quot;)</span> <span class="hljs-comment">// 扫描mapper包</span><br><span class="hljs-meta">@EnableScheduling</span><br><span class="hljs-meta">@EnableAspectJAutoProxy(proxyTargetClass = true, exposeProxy = true)</span><br></code></pre></td></tr></table></figure><p>由于使用了mybatis，还需要再资源目录下<code>resources</code>新建mapper包并编写对应的mapper.xml与Mapper进行对应</p><p>mapper.xml格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.wenjelly.wenjellyojbackenduserservice.mapper.UserMapper&quot;</span>&gt;</span> # DAO层<br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.wenjelly.wenjellyojbacjendmodel.model.entity.User&quot;</span>&gt;</span> # 实体类位置<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Base_Column_List&quot;</span>&gt;</span><br>        id,unionId,mpOpenId,<br>        userName,userAvatar,userProfile,<br>        userRole,createTime,updateTime,isDelete<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以及还要手动引入负载均衡器的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>之后再启动项目进行排查就差不多了</p><h2 id="关于微服务改造中的网关模块"><a href="#关于微服务改造中的网关模块" class="headerlink" title="关于微服务改造中的网关模块"></a>关于微服务改造中的网关模块</h2><p>在oj平台中，题目服务位于 8081端口，用户服务位于8082端口，而判题服务则是位于8083端口</p><p>如果前端进行调用的话，会非常麻烦，所以就使用到了网关：前端将所有请求都集中起来，使用同一url转发给网关，然后再由网关进行分配</p><p>Spring Cloud GateWay，简称SCG，是一个应用层网关。而Nginx是接入层网关，也就是全局网关</p><p>这里简单的说一下网关的分类：</p><ol><li>全局网关（接入网关）：作用是负载均衡、请求日志等、不和业务逻辑绑定。常用的有 Nginx</li><li>业务网关（微服务网关）：会有一些业务逻辑（比如根据用户信息判断用户权限），作用是将请求转发到不同的业务 &#x2F; 项目 &#x2F; 接口 &#x2F; 服务。常用的有Spring Cloud GateWay</li></ol><p>学一门技术最主要的是要看它能用来干什么？</p><ul><li>可以聚合前端请求，并进行请求转发</li><li>集中的对服务进行管理、操作。比如集中解决跨域、鉴权、接口文档、服务路由、接口安全性、流量染色、限流</li></ul><p>当有一个请求进入到网关，网关会在注册中心查找是否有对应的服务，如果有，再查看服务模块有哪些地址，在从中选择一个就好了。如果有多个地址，就可以采用负载均衡进行控制流量了。</p><p>第一步：导入SCG的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接下来如何判断需要转发到哪个服务中呢？</p><p>在<code>application.yaml</code>中进行配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br><span class="hljs-attr">cloud:</span><br><span class="hljs-attr">gateway:</span><br><span class="hljs-attr">routes:</span><br>                <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">wenjellyoj-backend-user-service</span> <br>                  <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://wenjellyoj-backend-user-service</span>  <span class="hljs-comment"># 负载均衡写法，当满足以下配置之后，会在Nacos中查找wenjellyoj-backend-user-service服务，如果有就从这个服务的其中一个地址进行调用即可</span><br>                  <span class="hljs-attr">predicates:</span> <span class="hljs-comment"># 配置，满足以下配置之后就会去找uri里面对应的服务</span><br>                    <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/api/user/**</span><br></code></pre></td></tr></table></figure><p>配置完之后我启动网关服务，遇到了以下问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs error">java.lang.IllegalArgumentException: Could not find class [org.springframework.cloud.client.loadbalancer.AsyncLoadBalancerAutoConfiguration]<br></code></pre></td></tr></table></figure><p>目前推测可能是依赖冲突导致的。</p><p>修改了以下maven仓库位置和仓库设置就成功了</p><p><img src="/.com//1718766569479.png" alt="1718766569479"></p><p>启动后有遇到以下错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs error">Parameter 0 of method inetIPv6Utils in com.alibaba.cloud.nacos.util.UtilIPv6AutoConfiguration required a bean of type &#x27;org.springframework.cloud.commons.util.InetUtilsProperties&#x27; that could not be found.<br></code></pre></td></tr></table></figure><p>经过长达2~3小时的排查，我发现是依赖冲突的问题：</p><p>我的主模块使用的Spring Cloud Alibaba 的版本是2021.0.5.0，而我网关模块的使用的则是2023.0.1版本的Spring Cloud</p><p>当我的网关模块使用到loadbalancer依赖时，我主模块导入的是 2021.0.5.0对应的3.1.5版本的loadbalancer，而由于我网关模块Spring Cloud版本较高，导入了4.1.2的loadbalancer，此时则造成了冲突，这里将网关模块的版本进行降级重试</p><p>发现俩处问题：</p><ol><li><p>主模块没导入这个依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>一开始的版本冲突</p></li></ol><p>折磨好久</p><p>网关gateway配置成功</p><p><img src="/.com//image-20240619171636809.png" alt="image-20240619171636809"></p><h2 id="关于微服务改造中聚合文档的使用"><a href="#关于微服务改造中聚合文档的使用" class="headerlink" title="关于微服务改造中聚合文档的使用"></a>关于微服务改造中聚合文档的使用</h2><p>这里我选择给3个服务模块进行聚合文档：用户服务、题目服务、判题服务</p><p>首先对每个服务引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.xiaoymin<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>knife4j.openapi2-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对每个服务进行配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">knife4j:</span><br><span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>接下来在网关服务进行聚合</p><p>同理，先对网关服务进行依赖导入</p><p>之后进行配置，这里使用聚合配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">knife4j:</span><br><span class="hljs-attr">gateway:</span><br><span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 选择手动配置</span><br><span class="hljs-attr">strategy:</span> <span class="hljs-string">manual</span><br><span class="hljs-attr">routes:</span><br><span class="hljs-string">-name:</span><br><span class="hljs-attr">service-name:</span><br><span class="hljs-attr">url:</span><br><span class="hljs-string">····</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">knife4j:</span><br>  <span class="hljs-attr">gateway:</span><br>    <span class="hljs-comment"># ① 第一个配置，开启gateway聚合组件</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># ② 第二行配置，设置聚合模式采用discover服务发现的模式</span><br>    <span class="hljs-attr">strategy:</span> <span class="hljs-string">discover</span><br>    <span class="hljs-attr">discover:</span><br>      <span class="hljs-comment"># ③ 第三行配置，开启discover模式</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment"># ④ 第四行配置，聚合子服务全部为Swagger2规范的文档</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">swagger2</span><br><br></code></pre></td></tr></table></figure><p>之后访问网关地址&#x2F;doc.html即可</p><h2 id="解决微服务改造分布式-Session-登录"><a href="#解决微服务改造分布式-Session-登录" class="headerlink" title="解决微服务改造分布式 Session 登录"></a>解决微服务改造分布式 Session 登录</h2><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- redis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.session<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-session-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加配置信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">session:</span><br><span class="hljs-attr">store-type:</span><span class="hljs-string">redis</span><br><span class="hljs-attr">tiemout:</span> <span class="hljs-number">259200</span><br></code></pre></td></tr></table></figure><p>session 跨域问题解决</p><p>如果session发送的path不对，比如在题目携带的用户session发送到了&#x2F;api&#x2F;question下</p><p>而用户在用户模块则是发送到了&#x2F;api&#x2F;user下，则这就会导致系统以为这俩个并不是同一个用户</p><p>在每个服务中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">session:</span><br>      <span class="hljs-attr">cookie:</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/api</span><br></code></pre></td></tr></table></figure><h2 id="解决微服务网关跨域问题"><a href="#解决微服务网关跨域问题" class="headerlink" title="解决微服务网关跨域问题"></a>解决微服务网关跨域问题</h2><p>有个问题：什么是跨域？跨域的解决办法有什么？</p><p>在网关模块新增一个配置类<code>config</code>下<code>CorsConfig</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CorsConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CorsWebFilter <span class="hljs-title function_">corsWebFilter</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-type">CorsConfiguration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsConfiguration</span>();<br>        config.addAllowedMethod(<span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-comment">// 是否允许证书（cookies）</span><br>        config.setAllowCredentials(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// todo 修改问本地地址 / 线上地址</span><br>        config.setAllowedOriginPatterns(Arrays.asList(<span class="hljs-string">&quot;*&quot;</span>));<br>        config.addAllowedHeader(<span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-type">UrlBasedCorsConfigurationSource</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UrlBasedCorsConfigurationSource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PathPatternParser</span>());<br>        source.registerCorsConfiguration(<span class="hljs-string">&quot;/**&quot;</span>, config);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsWebFilter</span>(source);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完善微服务网关权限校验"><a href="#完善微服务网关权限校验" class="headerlink" title="完善微服务网关权限校验"></a>完善微服务网关权限校验</h2><p>在网关模块新增一个过滤器配置器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalAuthFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AntPathMatcher</span> <span class="hljs-variable">antPathMatcher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AntPathMatcher</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>        <span class="hljs-comment">// 获得一些请求信息，可以根据路径判断哪些是可以访问，哪些是不能访问的</span><br>        <span class="hljs-type">ServerHttpRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> exchange.getRequest();<br>        <span class="hljs-comment">// 拿到请求实际地址</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> request.getURI().getPath();<br>        <span class="hljs-keyword">if</span> (antPathMatcher.match(<span class="hljs-string">&quot;/**/inner/**&quot;</span>, path)) &#123;<br>            <span class="hljs-comment">// 拒绝请求</span><br>            <span class="hljs-type">ServerHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> exchange.getResponse();<br>            response.setStatusCode(HttpStatus.FORBIDDEN);<br>            <span class="hljs-comment">// 返回给用户信息</span><br>            <span class="hljs-type">DataBufferFactory</span> <span class="hljs-variable">dataBufferFactory</span> <span class="hljs-operator">=</span> response.bufferFactory();<br>            <span class="hljs-type">DataBuffer</span> <span class="hljs-variable">dataBuffer</span> <span class="hljs-operator">=</span> dataBufferFactory.wrap(<span class="hljs-string">&quot;无权限&quot;</span>.getBytes(StandardCharsets.UTF_8));<br>            <span class="hljs-keyword">return</span> response.writeWith(Mono.just(dataBuffer));<br>        &#125;<br>        <span class="hljs-comment">// 其他权限校验</span><br>        <span class="hljs-keyword">return</span> chain.filter(exchange);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以在网关层面增加一个全局权限校验，网关由于是反应式编程，拿不到HttpsSevletRequest，所以很难在网关层面获取信息</p><blockquote><p>扩展：网关层面还可以做限流，参考教程：<a href="https://sca.aliyun.com/zh-cn/docs/2021.0.5.0/user-guide/sentinel/overview">https://sca.aliyun.com/zh-cn/docs/2021.0.5.0/user-guide/sentinel/overview</a></p><p>扩展：使用 JWT Token 实现用户登录，在网关层面通过token获取登录信息，实现鉴权</p></blockquote><h2 id="关于微服务改造中消息队列的使用"><a href="#关于微服务改造中消息队列的使用" class="headerlink" title="关于微服务改造中消息队列的使用"></a>关于微服务改造中消息队列的使用</h2><p>一、去官网安装RabbitMQ</p><p>二、启动RabbitMQ并打开管理面板，端口：15672</p>]]></content>
    
    
    
    <tags>
      
      <tag>标签</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法学习</title>
    <link href="/2024/07/04/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/07/04/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在大二、大三阶段忙于锻炼开发能力，算法能力逐步下降了，于是打算在实习期间重新巩固一下算法能力，并通过这篇文章记录一下学习过程，方便日后复习。</p><p>学习算法时，知识的连贯性是非常重要的，因此，单独学习算法是不够的，最好是要将他们连贯起来，比如他们的区别、用法等相似之处与不同之处，需要做一个系统的学习来完善这方面的知识连贯性</p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>原理：将一个无序数组中的元素俩俩进行比较，如果前者大于后者（升序），则替换位置，直到循环到最后一个元素，此为第一趟排序，届时会确定一个 最大&#x2F;最小数（升序则为最大数，反之则为最小数），确定的数会放在数组的最后一个元素上。依次循环n趟排序（n为数组大小），就实现了冒泡排序</p><p><strong>由于每一趟排序都会确定一个最大&#x2F;最小数，就像冒泡一样往上冒</strong></p><p>特点：由于每一趟排序都会确定一个最大&#x2F;最小数，所以下一趟相互比较的次数都比前一轮少一次。一共需要n-1轮排序</p><p>时间复杂度：最好：O(n)，平均：O（n^2^），最坏O（n^2^）</p><p>空间复杂度：O(1)</p><p>稳定性：稳定</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取一个无序数组</span><br><span class="hljs-type">int</span>[] arr = NumberArr.getRandomArr();<br>System.out.println(<span class="hljs-string">&quot;排序前：&quot;</span> + Arrays.toString(arr));<br><span class="hljs-comment">// 用于替换</span><br><span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 循环次数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    <span class="hljs-comment">// 每次循环都会得到一个 最大数/最小数，最大数/最小数 会反正数组的最后</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length - i - <span class="hljs-number">1</span>; j++) &#123;<br>        <span class="hljs-comment">// 如果前一个数大于后一个数，则交换 每一次排序都会得到一个最大数</span><br>        <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>            temp = arr[j + <span class="hljs-number">1</span>];<br>            arr[j + <span class="hljs-number">1</span>] = arr[j];<br>            arr[j] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;排序后：&quot;</span> + Arrays.toString(arr));<br></code></pre></td></tr></table></figure><p>如果数组已经排好序了，可以在最外面定义个flag，如果在第二层循环中有数的交换，那么就改变flag的值。反之如果一趟排序下来了，flag未被改变，说明原数组已经有序了，就可以直接退出所有循环了，此时时间复杂度就是O（n）了。但是如果通过这样判断也有一点缺点，比如每次交换都要进行赋值操作，已经新开辟了一个flag的空间</p><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序，顾名思义，是一种速度非常快的排序算法，为什么快速排序快呢？因为它的思想是分而治之，将一个问题划分为多个子问题，再依次使用分治去处理子问题直到无法划分问题</p><p>首先通过随机算法选取一个基准，然后将小于等于基准的数划分为一个子数组并放到基准左边，将大于基准的数划分为另一个子数组并放到基准右边，同时在对这俩个子数组进行同样的操作</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ</title>
    <link href="/2024/06/03/RabbitMQ/"/>
    <url>/2024/06/03/RabbitMQ/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-API-操作手册"><a href="#Java-API-操作手册" class="headerlink" title="Java API 操作手册"></a>Java API 操作手册</h1><p>介绍一下RabbitMQ的几个端口：</p><table><thead><tr><th align="center">端口</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">15672</td><td align="center">管理界面ui使用的端口</td></tr><tr><td align="center">15671</td><td align="center">管理监听端口</td></tr><tr><td align="center">5672，5671</td><td align="center">AMQP 0-9-1 without and with TLSclient端通信口</td></tr><tr><td align="center">4369</td><td align="center">（epmd)epmd代表 Erlang端口映射守护进程，erlang发现口</td></tr><tr><td align="center">25672</td><td align="center">( Erlang distribution） server间内部通信口</td></tr></tbody></table><h2 id="“Hello-World”"><a href="#“Hello-World”" class="headerlink" title="“Hello World”"></a>“Hello World”</h2><p><strong>一、下载RabbitMQ</strong></p><p>这里介绍的是Windows环境下的安装，有很多种安装方式，具体可以看官方文档</p><blockquote><p><a href="https://www.rabbitmq.com/docs/download">Installing RabbitMQ | RabbitMQ</a></p></blockquote><p>首先需要安装Erlang&#x2F;OTP，其次就是安装RabbitMQ了</p><blockquote><p><a href="https://www.rabbitmq.com/docs/install-windows#installer">RabbitMQ：一个代理将它们全部排队 |兔子MQ</a></p></blockquote><p>但是需要注意版本兼容问题，安装完之后就可以了，RabbitMQ是自启动的</p><p><strong>二、导入RabbitMQ依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.rabbitmq/amqp-client --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>amqp-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.21.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>三、发送端（生产者）</strong></p><p>编写发送端的代码，向消息队列发送 “Hello World”</p><p>发送端的统一流程：</p><ol><li>创建连接工厂</li><li>设置连接地址</li><li>创建连接</li><li>创建通道</li><li>声明队列</li><li>发送消息到队列</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建连接工厂</span><br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        <span class="hljs-comment">// 设置连接地址</span><br>        factory.setHost(<span class="hljs-string">&quot;localhost&quot;</span>);<br>        <span class="hljs-comment">// 创建连接</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection();<br>             <span class="hljs-comment">// 创建通道</span><br>             <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel()) &#123;<br>            <span class="hljs-comment">// 声明一个队列</span><br>            channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>            <span class="hljs-comment">// 发送信息</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>            <span class="hljs-comment">// 发送信息到消息队列上</span><br>            <span class="hljs-comment">// 参数：1.交换机 2.队列名称 3. 4.消息内容</span><br>            channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, <span class="hljs-literal">null</span>, message.getBytes());<br>            System.out.println(<span class="hljs-string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>四、接收端（消费者）</strong></p><p>对于接收端来说，我们也同样需要声明一个与发送端相同；我们需要创建一个连接和通道 <code>channel</code>，声明接收端使用的队列，<strong>需要与发送端队列匹配</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        factory.setHost(<span class="hljs-string">&quot;localhost&quot;</span>);<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection();<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        System.out.println(<span class="hljs-string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>);<br><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot; [x] Received &#x27;&quot;</span> + message + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>        &#125;;<br>        channel.basicConsume(QUEUE_NAME, <span class="hljs-literal">true</span>, deliverCallback, consumerTag -&gt; &#123;<br>        &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>为什么不把通道<code>channel</code>和连接的创建与关闭放在<code>try-with-resource</code>中？</strong></p><p>官方文档是这样解释的：</p><blockquote><p>因为 我们希望在消费者倾听的同时，这个过程仍然有效 异步地让消息到达</p></blockquote><p>在发送端和接收端中，都需要编写重复的创建连接代码，这里可以进行简化，将这些代码抽取出来，创建一个连接管理类，用于返回创建好的连接</p><h2 id="RabbitMQ的几种模式"><a href="#RabbitMQ的几种模式" class="headerlink" title="RabbitMQ的几种模式"></a>RabbitMQ的几种模式</h2><p><strong>一、 Work Queues 工作模式</strong></p><p>当有多个消费者时，对于消息队列里面的内容，消费者之间的是竞争关系，即每个消费竞争消息队列里面的内容</p><p><strong>二、 Publish&#x2F;Subscribe 发布订阅模式</strong></p><p>交换机采用广播的方式将消息分发到所有队列</p><p><strong>三、 Routin 路由模式</strong></p><p>根据具体的路由键进行匹配转发</p><p><strong>四 、Topics 主题模式</strong></p><p>使用通配符进行路由转发</p><h2 id="Spring-Boot-配置-RabbitMQ"><a href="#Spring-Boot-配置-RabbitMQ" class="headerlink" title="Spring Boot 配置 RabbitMQ"></a>Spring Boot 配置 RabbitMQ</h2><p><strong>一、Spring Boot 整合 RabbitMQ 依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>二、编写配置文件</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br><span class="hljs-attr">rabbitmq:</span><br><span class="hljs-attr">host:</span><br><span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br><span class="hljs-attr">username:</span> <span class="hljs-string">guest</span><br><span class="hljs-attr">password:</span> <span class="hljs-string">guest</span><br><span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span><br></code></pre></td></tr></table></figure><p><strong>三、编写监听类（消费者）</strong></p><p>如果 服务器上没有对应的交换机和队列的话，就需要这么些注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageListener</span> &#123;<br><br><span class="hljs-comment">// 定义交换机常量</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_DIRECT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;exchange.direct.order&quot;</span>;<br><span class="hljs-comment">// 定义路由键</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;order&quot;</span>;<br><span class="hljs-comment">// 定义队列名称</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;queue.order&quot;</span>;<br><br><span class="hljs-comment">// 通过注解来进行监听（监听+ 创建）</span><br><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">// 监听的队列名称，durable是否持久化</span><br><span class="hljs-meta">value = @Queue(value = QUEUE_NAME,durable = &quot;true&quot;)</span><br><span class="hljs-meta">// 交换机名称</span><br><span class="hljs-meta">exchange = @Exchange(value = EXCHANGE_NAME)</span><br><span class="hljs-meta">// 路由规则</span><br><span class="hljs-meta">key = &#123;ROUTING_KEY&#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">)</span><br><span class="hljs-comment">// 三个参数：信息内容、信息体、通道</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doMessage</span><span class="hljs-params">(String dataMessage, Message message, Channel channel)</span> &#123;<br>.....业务逻辑<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 服务器 上有对应的交换机和队列，则可以直接这样写注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 表示只监听</span><br><span class="hljs-meta">@RabbitListener(queues = &#123;QUEUE_NAME&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doMessage</span><span class="hljs-params">(String dataMessage, Message message, Channel channel)</span> &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>编写发送端（生产者）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 引入Bean</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doMessage</span><span class="hljs-params">()</span> &#123;<br>rebbitTemplate.convertAndSend(EXCHANGE_DIRECT,ROUTING_KEY,dateMassge);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="RabbitMQ-可靠性研究"><a href="#RabbitMQ-可靠性研究" class="headerlink" title="RabbitMQ 可靠性研究 *"></a>RabbitMQ 可靠性研究 *</h2><p>研究以下故障情况</p><h3 id="一、消息没有发送到消息队列或交换机"><a href="#一、消息没有发送到消息队列或交换机" class="headerlink" title="一、消息没有发送到消息队列或交换机"></a>一、消息没有发送到消息队列或交换机</h3><h4 id="解决方式一：应答方式"><a href="#解决方式一：应答方式" class="headerlink" title="解决方式一：应答方式"></a>解决方式一：应答方式</h4><p>通过应答方式进行确认，有点类似于TCP的三次握手</p><p>当生产者调用了<code>convertAndSend</code>方法发送消息时，回调用<code>ConfirmCallback</code>和<code>ReturnsCallback</code>接口的回调函数<code>confirm</code>和<code>returnedMessage</code>方法</p><p><code>confirm</code>用于交换机应答</p><p><code>returnedMessage</code>用于队列应答，但是只有当消息发送到队列失败时，才会调用这个函数</p><p><strong>编写配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ConfirmCallback</span>,ReturnsCallback &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">confirm</span><span class="hljs-params">(CorrelationData correlationData, <span class="hljs-type">boolean</span> ack, String cause)</span> &#123;<br>log.info(<span class="hljs-string">&quot;CorrelationData &quot;</span> + correlationData);<br>log.info(<span class="hljs-string">&quot;交换机是否接收到消息： &quot;</span> + ack);<br>log.info(<span class="hljs-string">&quot;错误信息： &quot;</span> + cause);<br>&#125;<br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">returnedMessage</span><span class="hljs-params">(ReturnedMessage returned)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;消息主体:&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(returned.getMessage().getBody()));<br>        log.info(<span class="hljs-string">&quot;应答码:&quot;</span> + returned.getReplyCode());<br>        log.info(<span class="hljs-string">&quot;描述:&quot;</span> + returned.getReplyText());<br>        log.info(<span class="hljs-string">&quot;消息使用的交换器 exchange : &quot;</span> + returned.getExchange());<br>        log.info(<span class="hljs-string">&quot;消息使用的路由键 routing : &quot;</span> + returned.getRoutingKey());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写完配置类还不够，还需要将这个配置类装配到<code>RabbitTemplate</code>类里面，所以还需要编写一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><span class="hljs-comment">// 加了这个注解就可以当这个类有对象创建的时候自动执行</span><br><span class="hljs-comment">// 由于 RabbitConfig 加了 @Configuration 注解，所以Spring Boot 在启动的时候会自动创建bean</span><br><span class="hljs-meta">@PostConstruct</span>     <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initRabbitTemplate</span><span class="hljs-params">()</span> &#123;<br>rabbitTemplate.setConfirmCallback(<span class="hljs-built_in">this</span>);<br>rabbitTemplate.setReturnsCallback(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解决方式二：备份交换机"><a href="#解决方式二：备份交换机" class="headerlink" title="解决方式二：备份交换机"></a>解决方式二：备份交换机</h4><p>场景：如果交换机故障了，就可以使用备用交换机进行接收</p><h3 id="二、如果消息队列服务器宕机导致内存消息丢失怎么办"><a href="#二、如果消息队列服务器宕机导致内存消息丢失怎么办" class="headerlink" title="二、如果消息队列服务器宕机导致内存消息丢失怎么办"></a>二、如果消息队列服务器宕机导致内存消息丢失怎么办</h3><p>消息默认持久化到硬盘上，重启后会从硬盘上读取原来的消息</p><h3 id="三、消费端宕机或抛异常导致消息没有成功被消费"><a href="#三、消费端宕机或抛异常导致消息没有成功被消费" class="headerlink" title="三、消费端宕机或抛异常导致消息没有成功被消费"></a>三、消费端宕机或抛异常导致消息没有成功被消费</h3><p>通过应答方式进行确认：</p><p>如果消费端消费信息成功，给服务器返回ACK信息，消息队列删除消息</p><p>如果消费端消息信息失败，给服务器返回NACK信息，同时把消息恢复成待消费状态</p><p><strong>一、先添加配置信息</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br><span class="hljs-attr">rabbit:</span><br><span class="hljs-attr">listener:</span><br><span class="hljs-attr">simple:</span><br><span class="hljs-attr">acknowledge-mode:</span> <span class="hljs-string">manual</span> <span class="hljs-comment"># 手动确认,默认的是不管消费成功或消费不成功都返回ACK</span><br></code></pre></td></tr></table></figure><p><strong>二、在业务逻辑里面手动应答（消费端）</strong></p><p>一些参数：</p><p><code>deliveryTag</code>：交付标签机制，相当于消息在队列里的id，由64位组成，相当于8字节</p><p><code>multiple</code>：当为true时，对前面的消息进行批量处理，为false时，单独执行这一条消息，一般为false</p><p><code>requeue</code>: 控制消息是否重新放回队列</p><p>首先先用<code>try-catch</code>包围执行消息队列的业务逻辑，然后手动应答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 表示只监听</span><br><span class="hljs-meta">@RabbitListener(queues = &#123;QUEUE_NAME&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doMessage</span><span class="hljs-params">(String dataMessage, Message message, Channel channel)</span> &#123;<br>    <br>    <span class="hljs-comment">// 获取当前消息的deliverTag</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">deliveryTag</span> <span class="hljs-operator">=</span> message.getMessageProperties().getDeliveryTag();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 执行业务逻辑</span><br>        ....<br>        <span class="hljs-comment">// 执行成功，应答ack</span><br>        channel.basicAck(deliveryTag,multiple);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        <span class="hljs-comment">// 获取当前消息是否是第一次发送</span><br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">redelivered</span> <span class="hljs-operator">=</span> message.getMessageProperties().getRedelivered();<br>        <br>        <span class="hljs-keyword">if</span> (redelivered) &#123;<br><span class="hljs-comment">// 说明第一次放回，可以放回队列</span><br>            <span class="hljs-comment">// 失败返回nack</span><br>        channel.basicNack(deliveryTag,multiple,<span class="hljs-literal">true</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 不放回队列，因为不是第一次放回队列了</span><br>            channel.basicNack(deliveryTag,multiple,<span class="hljs-literal">false</span>);<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="RabbitMQ-限流"><a href="#RabbitMQ-限流" class="headerlink" title="RabbitMQ 限流 *"></a>RabbitMQ 限流 *</h2><p>配置参数学习：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br><span class="hljs-attr">rabbit:</span><br><span class="hljs-attr">listener:</span><br><span class="hljs-attr">simple:</span><br><span class="hljs-attr">acknowledge-mode:</span> <span class="hljs-string">manual</span> <span class="hljs-comment"># 手动确认,默认的是不管消费成功或消费不成功都返回ACK</span><br><span class="hljs-attr">prefetch:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 每次从队列中取回消息的数量</span><br></code></pre></td></tr></table></figure><h2 id="RabbitMQ-消息超时"><a href="#RabbitMQ-消息超时" class="headerlink" title="RabbitMQ 消息超时 *"></a>RabbitMQ 消息超时 *</h2><p>当一个消息一直在队列里面，消息可能会堆积，从而造成服务器存储空间耗尽</p><p><strong>为此，需要给消息设置一个超时时间，超过这个时间未被取走的消息则会被删除</strong></p><p>可以从俩个方面进行设置：</p><p>一：设置队列过期时间，并不是过期之后把整个队列删除，而是加入到这个队列里面的消息都统一过期时间</p><p>二：设置单条消息的过期时间</p><p><strong>关于设置队列整体过期时间，可以在图形化界面设置</strong></p><p><strong>设置单条过期时间可以通过API设置（生产端）</strong></p><p>在消息后置处理器里面设置过期时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建消息后置处理器</span><br><span class="hljs-type">MessagePostProcessor</span> <span class="hljs-variable">messagePostProcessor</span> <span class="hljs-operator">=</span> message -&gt; &#123;<br><span class="hljs-comment">// 设置过期时间，单位毫秒，并且是String类型</span><br>message.getMessageProperties().setExpiration(<span class="hljs-string">&quot;7000&quot;</span>);<br><span class="hljs-keyword">return</span> message;<br>&#125;<br>rabbitTemplate.converAndSend(<span class="hljs-string">&quot;交换机名称&quot;</span>,<span class="hljs-string">&quot;队列路由&quot;</span>,<span class="hljs-string">&quot;消息体&quot;</span>);<br><br></code></pre></td></tr></table></figure><h2 id="RabbitMQ-死信"><a href="#RabbitMQ-死信" class="headerlink" title="RabbitMQ 死信 *"></a>RabbitMQ 死信 *</h2><p>消息超时后会变成死信，死信的产生大概有以下三种：</p><ol><li>拒绝：消费端拒绝消费该消息&#x2F;无法消费该消息，当消费端返回nack并且不把消息放回队列时，就会产生死信</li><li>溢出：队列中消息的数量达到上限，再向队列发送消息便成了死信</li><li>超时：消息到达超时时间未被消费</li></ol><p>死信的处理方式：</p><ol><li>丢弃：对于不重要的消息直接丢弃，不做处理</li><li>入库：把死信写入数据库，日后处理</li><li>监听：消息变成死信后进入死信队列，设置专门的消费端监听死信队列，做后续处理（常用）</li></ol><p><strong>正常队列要绑定对应的死信队列，在图形化页面进行绑定</strong></p><h2 id="RabbitMQ-延迟队列"><a href="#RabbitMQ-延迟队列" class="headerlink" title="RabbitMQ 延迟队列 *"></a>RabbitMQ 延迟队列 *</h2><p>所谓的延迟队列就是在延迟时间后才进行处理</p><p><strong>方法一：借助消息超时时间 + 死信队列</strong></p><p><strong>方法二：给 RabbitMQ 安装插件</strong></p><p>安装完插件之后，在图形化页面设置交换机，将&#96;&#96;type<code>选择为插件，然后在下面的</code>Arguments<code>那绑定交换机的转发模式：</code>x-delayed-type<code>=</code>direct&#96;</p><p>延迟队列的设置同样是在后置处理器上设置的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 得到后置处理器</span><br><span class="hljs-type">MessagePostProcessor</span> <span class="hljs-variable">postProcessor</span> <span class="hljs-operator">=</span> message -&gt; &#123;<br><span class="hljs-comment">// 设置消息过期时间，并传入 x-delayc 参数作为延迟队列</span><br>message.getMessageProperties().setHeader(<span class="hljs-string">&quot;x-delat&quot;</span>,<span class="hljs-string">&quot;10000&quot;</span>);<br><span class="hljs-keyword">return</span> message;<br>&#125;<br><span class="hljs-comment">// 发送消息</span><br>rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;交换机名称&quot;</span>,<span class="hljs-string">&quot;转发路由&quot;</span>,<span class="hljs-string">&quot;消息内容&quot;</span>,<span class="hljs-string">&quot;后置处理器&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="RabbitMQ-事务"><a href="#RabbitMQ-事务" class="headerlink" title="RabbitMQ 事务"></a>RabbitMQ 事务</h2><p>RabbitMQ事务作用非常局限，通常来说，生产端发送消息后，会先进入缓存，而事务控制的就是缓存，如果中途发生了异常，则会回滚缓存里面的内容。为什么说局限呢，因为即使不回滚缓存，缓存发送到交换机时，也可能导致消息发送失败，比如中途网络断开，或者交换机突然宕机了。</p><p>开启事务的话，需要在生产端上加入该注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br></code></pre></td></tr></table></figure><h2 id="RabbitMQ-惰性队列"><a href="#RabbitMQ-惰性队列" class="headerlink" title="RabbitMQ 惰性队列"></a>RabbitMQ 惰性队列</h2><p>默认就是惰性队列</p><p>先讲诉一下队列持久化</p><p><strong>什么时候会将队列里面的消息进行持久化呢？</strong></p><p>并不是当消息一进入队列的时候就进行持久化，而是当队列消息<del>满了</del>（大概百分之70~80）的时候就会进行队列持久化</p><p>或者当队列要要关闭时，才会进行持久化，在持久化时。消息的存入操作会被阻塞</p><p><strong>所谓的惰性队列就是持久化的时机：当服务器空闲时，就进行持久化</strong></p><h2 id="RabbitMQ-优先级队列"><a href="#RabbitMQ-优先级队列" class="headerlink" title="RabbitMQ 优先级队列"></a>RabbitMQ 优先级队列</h2><p>RabbitMQ允许我们使用一个正整数给消息设定优先级</p><p>消息的优先级数值取值范围:1~255</p><p>RabbitMQ官网建议在1~5之间设置消息的优先级(优先级越高，占用CPU、<br>内存等资源越多)</p><p><strong>关于优先级的设置，同样也是需要使用后置处理器来操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 得到后置处理器</span><br><span class="hljs-type">MessagePostProcessor</span> <span class="hljs-variable">postProcessor</span> <span class="hljs-operator">=</span> message -&gt; &#123;<br><span class="hljs-comment">// 设置优先级</span><br>message.getMessageProperties().setPriority(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">return</span> message;<br>&#125;<br><span class="hljs-comment">// 发送消息</span><br>rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;交换机名称&quot;</span>,<span class="hljs-string">&quot;转发路由&quot;</span>,<span class="hljs-string">&quot;消息内容&quot;</span>,<span class="hljs-string">&quot;后置处理器&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>RabbitMQ</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
